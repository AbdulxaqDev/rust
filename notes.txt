 Let’s recap what we’ve learned so far about Cargo:
 
 We can create a project using `cargo new`.
 We can build a project using `cargo build`.
 We can build and run a project in one step using `cargo run`.
 We can build a project without producing a binary to check for errors using `cargo check`.
 Instead of saving the result of the build in the same directory as our code, Cargo stores it in the `target/debug/` directory.
 
 Building for Release
 When your project is finally ready for release, you can use `cargo build --release` to compile it with optimizations. 
 This command will create an executable in `target/release/` instead of `target/debug/`. The optimizations make 
 your Rust code run faster, but turning them on lengthens the time it takes for your program to compile. This is why 
 there are two different profiles: one for development, when you want to rebuild quickly and often, and another for building 
 the final program you’ll give to a user that won’t be rebuilt repeatedly and that will run as fast as possible. 
 If you’re benchmarking your code’s running time, be sure to run `cargo build --release` and benchmark with the executable 
 in `target/release/`.

[September 5, 2023]
 to include bult in library we need use `use` keyword as `#include` in c programmin language.

[April 11, 2024]
 Cargo initializes git on new projects. It does not, if new project is created already in git.
 To avoid git initialization, we can use --vcs flag.

[April 12, 2024]
 We can add external crate to Cargo.toml file to use in projetc.
 as rand:

 rand = "0.8.5"

 We can update used crates with 'cargo update'

 By default, variables are immutable in rust, to make them mutable, the 'mut' keyword need to be used
 
 let mut num = 7;
 
 Can't be used variables created with 'let' in blobal scope, but with 'conts' can be.
 The contant variables are always immutable, the type of value must be annotated and can be assigned to only 
 constant expression, not to a value that can be calculates at runtime. And, uppercase is used for constants.
 
 const NUM: i8 = 127;
 
 We can shadow variables
 
 let x = 5;
 let x = x + 18;
 
 last version of x will be used, this is shadowing.
 
 mut vs shadowing
 
 shadowed variable at the end stays immutable and its type can be changed while shadowing
 with the same variable name.
 
 let spaces = "    ";
 let spaces = spaces.len();

[April 14, 2024]
 Rust is expression based language. Need to understand the difference between
 statement and expression in rust.

 A statement does an action but does not return value.
 An expression finalize a rezult and returns it.

 An funtion call is expression. Macros are expression. But function signeture is statement.
 Variables are statement.

 let a = (let x = 7); // gives error


 let y = {
    let x = 4;
    x+2
 }  
 // here y is equials 6, how?
 Because the last statement in expression is returned.
 As we can see above, there is no semicolon after last state-
 ment. If we put semicolon after last statement, whole expression
 becomes statment and it does not work as expected.

 fn five() -> u8 {
    5
 }

 here is the function five is valid function and it returns five with
 return type of u8 (unsigned 8 byte integer).

 We can set parametres with its type in functions.
 
 fn muliply_by2(num: i128) -> i128 {
     num*2
 }

 Control flow
 In rust control flow is expresion, as we can see here

 let condition = true;
 let number = if condition {5} else {7};

 println!("num is {num}");

 -----
 let num = if condition { "5" } else { 6 };

 Here this code gives error, because both if and else arms should retunr the same type
 of data and the first value's type is expected for following conditions.

 "5" is string, so the the 6 is also ecpected to be string, so error will be thrown here.

 Loops
 In rusr there are three type of loops, loop, while and for;
 loop iterates forever, 

 loop {
   println!("again!");
 }

 we can stop it with break keyword or skip some iterations with continue keyword

 loop {
   if condition {
      break;
   }

   if condition2 {
      continue;
   }
 }
 
 loop is also expression, so we can return a vlaue

 loop {
   if condition {
      break value;
   }
 }

 ---
    let mut number = 0;

    let end_loop_result = loop {
        number += 1;
        if number == 10 {
            break number;
        }
    };

    println!("end loop result {end_loop_result}");
 ---

 we can also label a loop and break it with its label. To create lable we use single 
 quote then label and colon as following: 
 
 'label: loop {

   }
 
 Here an factory example, which produces material untill it has gas.
 When gas finishes the engine gets off. When the target material amount is made
 the whole factory gets turns off and prints produced material emount.
   ------
    let mut material = 0;
    let target = 10;

    'factory: loop {
        let mut gas = 3;
        println!("Material amount: {material}");
        println!("Starting engine!");

        loop {
            println!("Gas left: {gas}");
            if gas == 0 {
                println!("Stopping engine!");
                break;
            }
            if material == target {
                println!("We got enough, stoping factory!");
                break 'factory;
            }
            gas -= 1;
            material += 1;
        }
    }
    println!("Material are made: {material}");
   ------

[April 15, 2024]
    
 Ownership

 The Ownership is a set of rules rust uses for memory managment.
 There are three simple rules:
  i) any value has owner 
  ii) a vlue can have only one owner at a time 
  iii) when the scope ends a value in, the value is dropped

 To understand the ownership,  we need to understand the stack and heap.
 In rust some data are stored in stack and some in heap based on their types.
 We can with the example of string.
 When we create string literal:

    let s = "hello";

 this is hard coded and not expected to change at runtime or compile time. 
 if it is supposed to change, needed to use another type of string String:

      let mut s = String::from("Hello");
      s.push_str(", World");

 This type of string is stored on heap and can be modified. Its data is stored at heap, 
 but the pointer adress to this string is stored in stack.

    let s1 = String::from("Hello");
    let s2 = s1;

    println!("{}", s1);

 above the code gives error. Because s1 and s2 are could point to one pointer and when the scope ends, 
 they try to free the memory on heap twice, which coauses memory curruption. To prevent this, in rust, 
 s1 is moved to s2, so after s2 the s1 is invalidated. This is colled Move in rust.

 But some times we need to refence duplicates, so in that case we can clone it.

    let s1 = String::from("Hello");
    let s2 = s1.clone();

    println!("{}", s1);
    
 A function can return two values with tuple

 Reference

 we can refence a value without passing it to function with reference.

    fn main() {
        let g = String::from("Hello, there");

        let l = get_len(&g);

        println!("The length of '{}' is {}", g, l);
    }

    fn get_len(s: &String) -> usize{
        s.len()
    }

 Referenced value are immutable as variable by default. But, we can make it mutable
 with "mut":

 fn main() {
    let mut s = String::from("Hello, there | ");
     changes(&mut s);

     println!("{}", s);
 }

 fn changes(s: &mut String) {
     s.push_str("Hello there");
 }

 One restriction with referenced mutable value is it can only has one reference at a time. Following 
 code fails: 

    let mut s = String::from("Brendan");

    let r1 = &mut s;
    let r2 = &mut s;
    
    println!("{}, {}", r1, r2);    

 the same rule applies for mutable and imutable references at a time:
    let mut s = String::from("Brendan");

    let r1 = &s;
    let r2 = &mut s;
 test
    



 
